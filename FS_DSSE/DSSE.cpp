
#include "MasterKey.h" 
#include "DSSE.h"
#include "Keyword_Extraction.h"    
#include "Miscellaneous.h" 
#include "DSSE_Trapdoor.h"     
#include "DSSE_Crypto.h"
#include "DSSE_KeyGen.h"
#include "climits"
#include "Client_DSSE.h"
#include "math.h"
#include <thread>


typedef struct thread_computation
{
    int startIdx;
    int endIdx;
    unsigned char* encrypted_data;
    unsigned char* decrypted_data;
    unsigned char* key;
    
    thread_computation()
    {
        
    }
    ~thread_computation()
    {
        
    }
    thread_computation(int startIdx, int endIdx, unsigned char* encrypted_data, unsigned char* decrypted_data, unsigned char* key)
    {
        this->startIdx = startIdx;
        this->endIdx = endIdx;
        this->encrypted_data = encrypted_data;
        this->decrypted_data= decrypted_data;
        this->key = key;
    }
    
}THREAD_COMPUTATION;

unsigned int nthreads = std::thread::hardware_concurrency();
static void* thread_AES_CTR(void* args);
DSSE::DSSE()
{
    //register the PRNG with Fortuna
     
    int err;
    if ((err = register_prng(&fortuna_desc)) != CRYPT_OK) 
    {
		printf("Error registering Fortuna PRNG : %s\n", error_to_string(err));
	}

	if ((err = find_prng("fortuna")) != CRYPT_OK) 
    {
		printf("Invalid PRNG : %s\n", error_to_string(err));
	}

	/* start it */
	if ((err = fortuna_start(&prng)) != CRYPT_OK) 
    {
		printf("Start error: %s\n", error_to_string(err));
	}

	if ((err = fortuna_add_entropy((unsigned char*)seed.c_str(), seed.size(), &prng)) != CRYPT_OK) 
    {
		printf("Add_entropy error: %s\n", error_to_string(err));
	}
    if ((err = fortuna_ready(&prng)) != CRYPT_OK) 
    {
		printf("Ready error: %s\n", error_to_string(err));
	}
}

DSSE::~DSSE()
{
}

/**
 * Function Name: setupData_structure
 *
 * Description:
 * Buid all data structures needed for DSSE (incld. in client and server sides). The encrypted 
 * index is stored as files
 *
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param pKeywordCounterArray: (output) counter for each keyword
 * @param pBlockCounterArray: (output) counter for each file
 * @param pBlockStateMatrix: (output) state for each block
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param rFileName: (output) list of distinct files
 * @param path: (intput) location of file collection
 * @param pKey: (input) symmetric keys generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::setupData_structure(
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        TYPE_COUNTER *pKeywordCounterArray,
        TYPE_COUNTER *pBlockCounterArray,
        MatrixType **pBlockStateMatrix,
        vector<TYPE_INDEX> &lstFree_column_idx,
        vector<TYPE_INDEX> &lstFree_row_idx,
		vector<string> &rFileNames,
		string path,
		MasterKey *pKey)
{
	set<string>::iterator iter;
    
    unsigned char empty_label[6] = "EMPTY";
    unsigned char delete_label[7] = "DELETE";
    hashmap_key_class empty_key = hashmap_key_class(empty_label,6);
    hashmap_key_class delete_key = hashmap_key_class(delete_label,7);
    

	try
    {
        rT_W = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_KEYWORDS*KEYWORD_LOADING_FACTOR);
        rT_W.max_load_factor(KEYWORD_LOADING_FACTOR);
		rT_W.min_load_factor(0.0);
        rT_W.set_empty_key(empty_key);
		rT_W.set_deleted_key(delete_key);

		rT_F = TYPE_GOOGLE_DENSE_HASH_MAP(MAX_NUM_OF_FILES*KEYWORD_LOADING_FACTOR);
        rT_F.max_load_factor(FILE_LOADING_FACTOR);
		rT_F.min_load_factor(0.0);
		rT_F.set_empty_key(empty_key);
		rT_F.set_deleted_key(delete_key);
        
        lstFree_column_idx.reserve(MAX_NUM_OF_FILES);
        lstFree_column_idx.clear();
        lstFree_row_idx.reserve(MAX_NUM_KEYWORDS);
        lstFree_row_idx.clear();
        
        for(TYPE_INDEX j = 0 ; j < MAX_NUM_KEYWORDS; j++)
            lstFree_row_idx.push_back(j);
        for (TYPE_INDEX j = 0 ; j < MAX_NUM_OF_FILES; j++)
            lstFree_column_idx.push_back(j);        
        for(TYPE_INDEX i = 0 ; i < MAX_NUM_KEYWORDS;i++)
            pKeywordCounterArray[i] = 1;
        for(TYPE_INDEX i = 0 ; i < MAX_NUM_OF_FILES/ENCRYPT_BLOCK_SIZE;i++)
            pBlockCounterArray[i] = 1;

        printf("   1.0 Scanning whole database first....");
        this->scanDatabase(rFileNames,keywords_dictionary,rT_W,rT_F,path,pKey);
        if(keywords_dictionary.size() >= MAX_NUM_KEYWORDS)
        {
            printf("Error!\n The encrypted index size is not enough to handle all keywords in the DB, please increase the MAX_NUM_KEYWORDS in config.h\n");
            exit(1);
        }
        
        if (rFileNames.size() >= MAX_NUM_OF_FILES)
        {
            printf("Error!\n The encrypted index size is not enough to handle all files in the DB, please increase the MAX_NUM_OF_FILES in config.h\n");
            exit(1);
        }
        printf("OK!\n");
        cout<<"# unique kw: "<<keywords_dictionary.size()<<endl;
        cout<<"# unique files: "<<rFileNames.size()<<endl;

        printf("   1.1. Creating keyword and file pairs...");
        vector<vector<TYPE_INDEX>> kw_file_pair;
        kw_file_pair.reserve(MAX_NUM_OF_FILES);
        for(TYPE_INDEX col = 0 ; col <MAX_NUM_OF_FILES; col++)
        {
            vector<TYPE_INDEX> tmp;
            kw_file_pair.push_back(tmp);
        }
        auto start = time_now;
        this->createKeyword_file_pair(kw_file_pair,rT_W,rT_F,lstFree_row_idx, lstFree_column_idx, path,pKey);
        printf("OK!\n");
        printf("   1.1. Creating encrypted matrix...");
        this->createEncrypted_matrix_from_kw_file_pair(kw_file_pair, pKeywordCounterArray,pBlockCounterArray,pKey);
		printf("OK!\n");
        auto end = time_now;
        cout<<"BUILDING TIME: "<<std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count()<<" ms"<<endl;
        printf("   1.2. Creating block state matrix...");
        this->createBlock_state_matrix_files();
        printf("OK!\n");
	}
    catch(exception &e)
    {
		printf("Error!\n");
        exit(1);
	}


	return 0;
}

/**
 * Function Name: searchToken
 *
 * Description:
 * generate search token given a keyword being searched
 *
 * @param pSearchToken: (output) generated search token
 * @param keyword: (input) keyword being searched
 * @param pKey: (input) symmetric keys for data structure encryption
 * @return	0 if successful
 */
int DSSE::searchToken(SEARCH_TOKEN &pSearchToken,
		string keyword,
		MasterKey *pKey,
		unsigned char *keyword_counterS) 
{
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE] = {'\0'};
    TYPE_COUNTER keyword_counter;
    unsigned char row_key_input[BLOCK_CIPHER_SIZE] = {'\0'};
    
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen();
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    Miscellaneous misc;
	try
    {
        /* Generates the trapdoor for the keyword to be searched */
//        int keyword_length = strlen(keyword.c_str());
//        
//        dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, (unsigned char *)keyword.c_str(), keyword_length, pKey);
//        
//		
//		//**Done by Server
//        hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
//        if(rT_W[hmap_keyword_trapdoor]!=NULL)
//            pSearchToken.row_index = rT_W[hmap_keyword_trapdoor];
//        else
//        {
//            pSearchToken.row_index = KEYWORD_NOT_EXIST;
//            return 0;
//        }
//        if(pKeywordCounterArray[pSearchToken.row_index] == ULONG_MAX)
//        {
//            printf("Error! counter limit exceeded");
//            exit(1);
//        }
//        keyword_counter = pKeywordCounterArray[pSearchToken.row_index];
		//**
		
		
		unsigned char counter_keyword [BLOCK_CIPHER_SIZE] = {0};
		unsigned char ciphertext [BLOCK_CIPHER_SIZE] = {0};
		
		memcpy(counter_keyword,&pSearchToken.row_index,sizeof(pSearchToken.row_index));
				
		aes128_ctr_encdec(keyword_counterS, ciphertext, pKey->key4, counter_keyword, ONE_VALUE);
		memcpy(&keyword_counter, ciphertext, BLOCK_CIPHER_SIZE);
		memset(counter_keyword,0,BLOCK_CIPHER_SIZE);
		memset(ciphertext,0,BLOCK_CIPHER_SIZE);
		
		
        memset(row_key_input,0,sizeof(row_key_input));
        memcpy(row_key_input,&pSearchToken.row_index,sizeof(pSearchToken.row_index));
        memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));

        dsse_keygen->genRow_key(pSearchToken.row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
        
    }
    catch(exception &e)
    {
        printf("Error!!\n");
		exit(1);
    }

    memset(keyword_trapdoor,0,TRAPDOOR_SIZE);
    memset(row_key_input,0,BLOCK_CIPHER_SIZE);
    delete dsse_keygen;
    delete dsse_trapdoor;
	return 0;
}
/**
 * Function Name: search
 *
 * Description:
 * Perform keyword search over DSSE encrypted data structure, given a search token
 *
 * @param rFileIDs: (output) list of file ids in which the keyword being searched appears 
 * @param pSearchToken: (input) search token
 * @param I: (input) encrypted data structure
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateMatrix: (input) block states
 * @return	0 if successful
 */

int DSSE::search(   vector<TYPE_INDEX> &rFileIDs,
                    SEARCH_TOKEN pSearchToken,
                    MatrixType **I,
                    TYPE_COUNTER *pBlockCounterArray,
                    MatrixType **pBlockStateMatrix,
					string *D,
					TYPE_INDEX realRow,
					unsigned char *key)
{
	TYPE_INDEX row = 0, col = 0;
    TYPE_INDEX index = 0;
    int bit_number = 0, bit_value = 0, file_index = 0;
	vector<unsigned char>file_list;
	unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    Miscellaneous misc;
    int need_reencrypt = 0;
    string storedIndexes;
	string decryptedIndexes;
	string change;
	unsigned char temp[BLOCK_CIPHER_SIZE];
	unsigned char input[BLOCK_CIPHER_SIZE];
	unsigned char counter2[BLOCK_CIPHER_SIZE];
	unsigned char *temp2;
	unsigned char *temp3;
	unsigned long long counter;
	size_t size;
	long long int ind;
	std::size_t found;
	unsigned char* encrypted_data;
	unsigned char* decrypted_data;
	
	int selectedThreads = nthreads;
	//int selectedThreads = 8;
    pthread_t* thread_compute = new pthread_t[selectedThreads];
	THREAD_COMPUTATION* computeData_args = new THREAD_COMPUTATION[selectedThreads];
	int startIdx = 0;
	int endIdx, step;
    TYPE_INDEX block_idx;
    int ii,jj;
    if( pSearchToken.row_index< 0)
    {
        printf("Error!!\n");
        exit(1);
    }
	try
    {
        rFileIDs.clear();
        file_list.reserve(MATRIX_COL_SIZE);
		
        /* Get the row index for the keyword being searched */
		row = pSearchToken.row_index;
		storedIndexes = D[realRow];
		//cout << "\nStored indexes\n";
		//cout << storedIndexes;
        /* Decrypt blocks */
		if(storedIndexes.length()==0){
			for(index = 0, block_idx = 0; index < MAX_NUM_OF_FILES; index+=ENCRYPT_BLOCK_SIZE,block_idx++)
			{
				col = index / BYTE_SIZE;
				bit_number = index % BYTE_SIZE;
				for(ii=0 ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
				{
					if(BIT_CHECK(&I[row][col].byte_data,bit_number))
						BIT_SET(&V[0],ii);
					else
						BIT_CLEAR(&V[0],ii);
				}
				memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
				memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_idx],sizeof(TYPE_COUNTER));
				memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
			
				aes128_ctr_encdec(V, U, pSearchToken.row_key, uchar_counter, ONE_VALUE);
				for(ii=0; ii< ENCRYPT_BLOCK_SIZE;ii++)
				{
					if(BIT_CHECK(&U[0],ii)){
						rFileIDs.push_back((index+ii));
						storedIndexes.append(std::to_string(index+ii));
						storedIndexes.append(",");
					}
				}
            
           
            /* Set the state bit of this block to 0 */
				BIT_CLEAR(&pBlockStateMatrix[row][block_idx/BYTE_SIZE].byte_data,block_idx%BYTE_SIZE);
			}
			need_reencrypt = 1;
			size = BLOCK_CIPHER_SIZE*(ceil((double)storedIndexes.length()/(double)BLOCK_CIPHER_SIZE));
		}
		else{
			
			//Decrypt storedIndexes to temp with key and save to storedIndexes
			size = BLOCK_CIPHER_SIZE*(ceil((double)storedIndexes.length()/(double)BLOCK_CIPHER_SIZE));
			decryptedIndexes = "";
			
			
			// DEFINE A BOOLEAN AFTER THIS POINT AND EITHER CREATE THREADS OR NOT!!!
						
			step = BLOCK_CIPHER_SIZE*ceil((ceil((double)storedIndexes.length()/(double)BLOCK_CIPHER_SIZE))/(double)selectedThreads);
			
			if(step*(selectedThreads-1)<size){
			
				encrypted_data = new unsigned char[size];
				decrypted_data = new unsigned char[size];
				memset(encrypted_data, '0', size);
				memcpy(encrypted_data, (unsigned char*)storedIndexes.c_str(), storedIndexes.length());
				for(int i = 0, startIdx = 0; i < selectedThreads , startIdx < size; i ++, startIdx+=step)
				{
					if(startIdx+step > size)
						endIdx = size;
					else
						endIdx = startIdx+step;
						
					computeData_args[i] = THREAD_COMPUTATION(startIdx,endIdx,encrypted_data,decrypted_data,key);	
					pthread_create(&thread_compute[i], NULL, &thread_AES_CTR, (void*)&computeData_args[i]);
				
					cpu_set_t cpuset;
					CPU_ZERO(&cpuset);
					CPU_SET(i, &cpuset);
					pthread_setaffinity_np(thread_compute[i], sizeof(cpu_set_t), &cpuset);
					
					
				}
				for(int i  = 0 ; i < selectedThreads; i ++)
				{
					pthread_join(thread_compute[i],NULL);
				}
				
				std::string s2(decrypted_data, decrypted_data + size);
				string last = s2.substr(0, s2.rfind(",")+1);
				decryptedIndexes.append(last);
			}
			else{
				
				temp2 = new unsigned char[size];
				memset(temp2, '0', BLOCK_CIPHER_SIZE*(ceil(storedIndexes.length()/BLOCK_CIPHER_SIZE)));
				memcpy(temp2, (unsigned char*)storedIndexes.c_str(), storedIndexes.length());
				memset(counter2, '0', BLOCK_CIPHER_SIZE);
				
				memcpy(temp2, (unsigned char*)storedIndexes.c_str(), storedIndexes.length());
				counter = 0;
				for(int i = 0; i < ceil(storedIndexes.length()/BLOCK_CIPHER_SIZE); i++){
					memcpy(temp, temp2 + BLOCK_CIPHER_SIZE*i, BLOCK_CIPHER_SIZE);
					//Extend This If Your Database is Huge

					memcpy(counter2, &counter, sizeof(unsigned long long));
					counter++;
					
					
					aes128_ctr_encdec(temp, input, key, counter2, ONE_VALUE);
					memset(counter2,'0',BLOCK_CIPHER_SIZE);
					
					std::string s2(input, input + BLOCK_CIPHER_SIZE);
					if (i == ceil(storedIndexes.length()/BLOCK_CIPHER_SIZE)-1){
						string last = s2.substr(0, s2.rfind(",")+1);
						decryptedIndexes.append(last);
					}
					else{
						decryptedIndexes.append(s2);
					}
					s2.clear();
					memset(temp,0,BLOCK_CIPHER_SIZE);
					memset(input,0,BLOCK_CIPHER_SIZE);
				}
				
			}

			
			storedIndexes = decryptedIndexes;

			//Ozgur Write a for loop and if statement to check the state and update the string.
			for(index = 0, block_idx = 0; index < MAX_NUM_OF_FILES; index+=ENCRYPT_BLOCK_SIZE,block_idx++)
			{
				if(BIT_CHECK(&pBlockStateMatrix[row][block_idx/BYTE_SIZE].byte_data,block_idx%BYTE_SIZE))
				{
					col = index / BYTE_SIZE;
					bit_number = index % BYTE_SIZE;
					for(ii=0 ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
					{
						if(BIT_CHECK(&I[row][col].byte_data,bit_number))
							BIT_SET(&V[0],ii);
						else
							BIT_CLEAR(&V[0],ii);
					}
					memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
					memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&pBlockCounterArray[block_idx],sizeof(TYPE_COUNTER));
					memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
				
					aes128_ctr_encdec(V, U, pSearchToken.row_key, uchar_counter, ONE_VALUE);
					for(ii=0; ii< ENCRYPT_BLOCK_SIZE;ii++)
					{
						change = ","+std::to_string(index+ii)+",";
						found = storedIndexes.find(change);

						if(BIT_CHECK(&U[0],ii)&&found==std::string::npos){
							storedIndexes.append(std::to_string(index+ii));
							storedIndexes.append(",");
						}
						if(!BIT_CHECK(&U[0],ii)&&found!=std::string::npos){
							storedIndexes.erase(found+1, found+change.length());
						}
					}
					BIT_CLEAR(&pBlockStateMatrix[row][block_idx/BYTE_SIZE].byte_data,block_idx%BYTE_SIZE);
					need_reencrypt = 1;
				}
			}
			std::stringstream ss(storedIndexes);
			while (ss >> ind)
			{
				rFileIDs.push_back(ind);
	//			cout << ind;
				if (ss.peek() == ',')
					ss.ignore();
			}	
			
			
			
			
		}
		//Ozgur ENCRYPT D
		//D[realRow] = storedIndexes;
		
		
		if(need_reencrypt == 1){
			//Encrypt storedIndexes to D[realRow] with key
			D[realRow] = "";
			
			step = 16*ceil((ceil((double)storedIndexes.length()/(double)16))/(double)selectedThreads);
										
			if(step*(selectedThreads-1)<size){
				encrypted_data = new unsigned char[size];
				decrypted_data = new unsigned char[size];
				memset(encrypted_data, '0', size);
				memset(decrypted_data, '0', size);
				memcpy(encrypted_data, (unsigned char*)storedIndexes.c_str(), storedIndexes.length());
				
				
				
				for(int i = 0, startIdx = 0; i < selectedThreads , startIdx < size; i ++, startIdx+=step)
				{
					if(startIdx+step > size)
						endIdx = size;
					else
						endIdx = startIdx+step;
						
					computeData_args[i] = THREAD_COMPUTATION(startIdx,endIdx,encrypted_data,decrypted_data,key);	
					pthread_create(&thread_compute[i], NULL, &thread_AES_CTR, (void*)&computeData_args[i]);
				
					cpu_set_t cpuset;
					CPU_ZERO(&cpuset);
					CPU_SET(i, &cpuset);
					pthread_setaffinity_np(thread_compute[i], sizeof(cpu_set_t), &cpuset);
					
					
				}
				
				for(int i  = 0 ; i < selectedThreads; i ++)
				{
					pthread_join(thread_compute[i],NULL);
				}
				std::string s(decrypted_data, decrypted_data + size);
				D[realRow].append(s);
			}
			else{
				temp2 = new unsigned char[size];
				memset(temp2, '0', size);
		
				memcpy(temp2, (unsigned char*)storedIndexes.c_str(), storedIndexes.length());
				memset(counter2, '0', BLOCK_CIPHER_SIZE);
				counter = 0;
				for(int i = 0; i < ceil(storedIndexes.length()/16)+1; i++){
					memcpy(temp, temp2 + 16*i, BLOCK_CIPHER_SIZE);
					
					//Extend This If Your Database is Huge
					memcpy(counter2, &counter, sizeof(unsigned long long));
					counter++;
					
					aes128_ctr_encdec(temp, input, key, counter2, ONE_VALUE);
					memset(counter2,'0',BLOCK_CIPHER_SIZE);
					std::string s(input, input + 16);
					D[realRow].append(s);
					
					s.clear();
					memset(temp,0,BLOCK_CIPHER_SIZE);
					memset(input,0,BLOCK_CIPHER_SIZE);
				}
			}
		}
		
		storedIndexes.clear();
		decryptedIndexes.clear();
		file_list.clear();
	}
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }
	storedIndexes.clear();
	decryptedIndexes.clear();
	file_list.clear();
	memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
    memset(U,0,BLOCK_CIPHER_SIZE);
    memset(V,0,BLOCK_CIPHER_SIZE);
	memset(counter2,0,BLOCK_CIPHER_SIZE);
	return 0;
}

static void* thread_AES_CTR(void* args)
{
    THREAD_COMPUTATION* opt = (THREAD_COMPUTATION*) args;
    static thread_local unsigned char counter2[BLOCK_CIPHER_SIZE];
	static thread_local unsigned long long counter;
	memset(counter2, '0', BLOCK_CIPHER_SIZE);
    
//	std::cout << " Start Index =  " << opt->startIdx << "\n";
//	std::cout << " End Index = " << opt->endIdx << "\n";
	counter = opt->startIdx;
    for(int l = opt->startIdx ; l < opt->endIdx; l+=BLOCK_CIPHER_SIZE)
    {
		memcpy(counter2, &counter, sizeof(unsigned long long));
		counter++;
        aes128_ctr_encdec(&opt->encrypted_data[l],&opt->decrypted_data[l],opt->key,counter2,ONE_VALUE);
    }
	//memset(counter2,0,BLOCK_CIPHER_SIZE);
    pthread_exit((void*)opt);
}


/**
 * Function Name: addToken
 *
 * Description:
 * Generate a token for adding file
 *
 * @param new_adding_file_with_path: (input) full filename and path of the adding file
 * @param I_prime: (output) block_data after adding the file
 * @param file_index: (output) index of adding file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param extracted_keyword: (output) uniques keyword being extracted from adding file
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::addToken(     string new_adding_file_with_path,
                        MatrixType* I_prime,                 
                        TYPE_INDEX &file_index, 
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
                        TYPE_KEYWORD_DICTIONARY &extracted_keywords,
                        TYPE_COUNTER *pKeywordCounterArray,
                        TYPE_COUNTER *pBlockCounterArray,
                        bool *pBlockStateArray,
                        vector<TYPE_INDEX> &lstFree_column_idx,
                        vector<TYPE_INDEX> &lstFree_row_idx,
                        MasterKey* pKey)
{


    DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen(); 
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX keyword_index;
    TYPE_INDEX row,col;
    
    TYPE_INDEX idx,ii;
    
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
    
    TYPE_INDEX selectedIdx;
    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction* kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType* I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];


    try
    {
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)new_adding_file_with_path.c_str(), 
                                    new_adding_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        if(rT_F[hmap_file_trapdoor]==NULL)
        {
            this->pickRandom_element(selectedIdx,lstFree_column_idx,&prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        
        /* Extract unique keywords */
        kw_ex->extractKeywords(extracted_keywords, new_adding_file_with_path, "");
        
        for(iter=extracted_keywords.begin();iter != extracted_keywords.end();iter++) 
        {
            string word = *iter;
            int keyword_len = word.size();

            if(keyword_len>0)
            {
                dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
                                        (unsigned char *)word.c_str(), keyword_len, pKey);
            }
                
            hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor, TRAPDOOR_SIZE);
            
            if(rT_W[hmap_keyword_trapdoor]==NULL)
            {
                this->pickRandom_element(selectedIdx,lstFree_row_idx,&prng);
                rT_W[hmap_keyword_trapdoor] = selectedIdx;
            }
            
            keyword_index = rT_W[hmap_keyword_trapdoor];
            row = keyword_index / BYTE_SIZE;
            bit_position = keyword_index %BYTE_SIZE;

            BIT_SET(&I_bar[row].byte_data,bit_position);
            
            word.clear();
        }
        
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
        ii = (file_index % ENCRYPT_BLOCK_SIZE) / BYTE_SIZE; 
        bit_position = file_index % BYTE_SIZE;
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index];
        
       
		for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
		{
			keyword_counter = pKeywordCounterArray[row];
			memset(row_key_input,0,sizeof(row_key_input));
			memcpy(row_key_input,&row,sizeof(row));
			memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));

			dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
			
			memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
			memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
			memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
			
			I_bar_row = row / BYTE_SIZE;
			I_bar_bit_position = row % BYTE_SIZE;
			if(BIT_CHECK(&I_bar[I_bar_row].byte_data,I_bar_bit_position))
				BIT_SET(&U[0],0);
			else
				BIT_CLEAR(&U[0],0);

			aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
			
			if(BIT_CHECK(&V[0],0))
				BIT_SET(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
			else
				BIT_CLEAR(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
		}
		memcpy(I_prime,I_bar,MATRIX_ROW_SIZE/BYTE_SIZE);
    }
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;
   
    return 0;
}


/**
 * Function Name: delToken
 *
 * Description:
 * Generate a token for deleting file
 *
 * @param del_file_with_path: (input) full filename and path of the deleting file
 * @param I_prime: (output) block_data after deleting the file
 * @param file_index: (output) index of deleting file in the DSSE data structure
 * @param rT_F: (input) file hash table
 * @param rT_W: (input) keyword hash table
 * @param pKeywordCounterArray: (input) Keyword counters
 * @param pBlockCounterArray: (input) block counters
 * @param pBlockStateArray: (input) Block states
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param lstFree_row_idx: list of free row indexes not assigned to any keywords
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::delToken(string del_file_with_path,
			  MatrixType* I_prime,
			  TYPE_INDEX &file_index,
              TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
              TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
              TYPE_COUNTER *pKeywordCounterArray,
              TYPE_COUNTER *pBlockCounterArray,
              bool *pBlockStateArray,
              vector<TYPE_INDEX> &lstFree_column_idx,
              vector<TYPE_INDEX> &lstFree_row_idx,
              MasterKey* pKey){

	DSSE_Trapdoor *dsse_trapdoor = new DSSE_Trapdoor();
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen(); 
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row,col;
    
    TYPE_INDEX idx,ii;
    
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
    TYPE_INDEX block_index;
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    
    TYPE_COUNTER keyword_counter;
    TYPE_INDEX size;
    KeywordExtraction* kw_ex = new KeywordExtraction();
    set<string>::iterator iter;
    MatrixType* I_bar;
    unsigned char row_key[BLOCK_CIPHER_SIZE];
    unsigned char row_key_input[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    unsigned char U[BLOCK_CIPHER_SIZE], V[BLOCK_CIPHER_SIZE];
    

    try
    {
        I_bar= new MatrixType [MATRIX_ROW_SIZE/BYTE_SIZE];
        memset(I_bar,0,MATRIX_ROW_SIZE/BYTE_SIZE);
        
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)del_file_with_path.c_str(), 
                                    del_file_with_path.size(), pKey);
                                    
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
        
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index / ENCRYPT_BLOCK_SIZE;
		
        TYPE_COUNTER next_counter = pBlockCounterArray[block_index];
        
        /* Remove the file trapdoor entry from the file hashmap */
        lstFree_column_idx.push_back(file_index);
        rT_F.erase(hmap_file_trapdoor);
		
		
        
		for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
		{
			keyword_counter = pKeywordCounterArray[row];
			memset(row_key_input,0,sizeof(row_key_input));
			memcpy(row_key_input,&row,sizeof(row));
			memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&keyword_counter,sizeof(keyword_counter));
			dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
			
			memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
			memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&next_counter,sizeof(TYPE_COUNTER));
			memcpy(&uchar_counter,&block_index,sizeof(TYPE_INDEX));
			
			I_bar_row = row / BYTE_SIZE;
			I_bar_bit_position = row % BYTE_SIZE;
			
			BIT_CLEAR(&U[0],0);
			//encrypt
			aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
			
			if(BIT_CHECK(&V[0],0))
				BIT_SET(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
			else
				BIT_CLEAR(&I_bar[I_bar_row].byte_data,I_bar_bit_position);
		}
		memcpy(I_prime,I_bar,MATRIX_ROW_SIZE/BYTE_SIZE);
	}
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    // free memory
    delete dsse_trapdoor;
    delete kw_ex;
    delete dsse_keygen;
    delete I_bar;
   
    return 0;    
}



/**
 * Function Name: update
 *
 * Description:
 * Update the DSSE encrypted data structure, given a adding-file/deleting-file token
 *
 * @param I_prime: (input) block data being updated
 * @param block_index: (input) index of the block being updated
 * @param I: (output) DSSE encrypted data structure after update
 * @param pBlockCounterArray: (output) Block counters
 * @param pBlockStateMatrix: (output) block states
 * @return	0 if successful
 */
int DSSE::update(MatrixType* I_prime,              
            TYPE_INDEX block_idx,
            MatrixType** I,
            TYPE_COUNTER *pBlockCounterArray,
            MatrixType **pBlockStateMatrix)
            
{
    TYPE_INDEX row, col;
    TYPE_INDEX idx;
    TYPE_INDEX begin,end;
    TYPE_INDEX I_prime_bit_idx,I_prime_col_idx;
    TYPE_INDEX bit_position;
    TYPE_INDEX bit_number;
    try
    {
		col = block_idx / (BYTE_SIZE);
		bit_position = block_idx % BYTE_SIZE;
		for (row=0,idx=0;row<MATRIX_ROW_SIZE; row++,idx++)
		{
			I_prime_bit_idx = idx % BYTE_SIZE;
			I_prime_col_idx = idx / BYTE_SIZE;
			if(BIT_CHECK(&I_prime[I_prime_col_idx].byte_data,I_prime_bit_idx))
				BIT_SET(&I[row][col].byte_data,bit_position);
			else
				BIT_CLEAR(&I[row][col].byte_data,bit_position);
		}
        /* Iset the counter of this block to+1, set the state of the block to 1.*/
        if(pBlockCounterArray!=NULL)
            pBlockCounterArray[block_idx] = 1;
        if(pBlockStateMatrix !=NULL)
        {
            TYPE_INDEX col = block_idx/ BYTE_SIZE;
            TYPE_INDEX bit = block_idx % BYTE_SIZE;
            for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
            {
                BIT_SET(&pBlockStateMatrix[row][col].byte_data,bit);
            }
        }
		

    }
    catch(exception & e)
    {
        printf("Error!!\n");
        exit(1);
    }

    return 0;
}



/**
 * Function Name: updateBlock
 * 
 * Description:
 * Update the input block with a new column data
 *
 * @param updating_block: (input) the new data which will be used to update a column data in the input block
 * @param input_block: (input) block going to be updated
 * @param update_idx: (input) the index of columns which will be updated in the input block
 * @return	0 if successful
 */
 
int DSSE::updateBlock(  MatrixType* updating_block,
                        MatrixType* input_block,
                        TYPE_INDEX update_idx)
{
    Miscellaneous misc;
    int bit_position;
    TYPE_INDEX row,col;
    TYPE_INDEX idx,ii,size;
    TYPE_INDEX I_bar_idx, I_bar_row,I_bar_bit_position;
	memcpy(input_block,updating_block,MATRIX_ROW_SIZE/BYTE_SIZE);
	return 0;
}


/**
 * Function Name: requestBlock_index
 *
 * Description:
 * generate the block index, given a name of file being added
 *
 * @param adding_filename_with_pad: (input) full path and name of the file being added
 * @param block_index: (output) block index of the adding file
 * @param rT_F: (input) file hash table
 * @param lstFree_column_idx: list of free column indexes not assigned to any files
 * @param pKey: (input) symmetric key generated by genMasterKey()
 * @return	0 if successful
 */
int DSSE::requestBlock_index(   string adding_filename_with_pad,
                                TYPE_INDEX &block_index,
                                TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
                                vector<TYPE_INDEX> &lstFree_column_idx,
                                MasterKey *pKey)       
{       
    unsigned char file_trapdoor[TRAPDOOR_SIZE];
    TYPE_INDEX file_index;
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    TYPE_INDEX selectedIdx;
    try
    {
        dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
                                    (unsigned char *)adding_filename_with_pad.c_str(), 
                                    adding_filename_with_pad.size(), pKey);
        hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
		
		
        if(rT_F[hmap_file_trapdoor] == NULL)
        {
            this->pickRandom_element(selectedIdx,lstFree_column_idx,&prng);
            rT_F[hmap_file_trapdoor] = selectedIdx;
        }
        // Get the file index from the hashmap
        file_index = rT_F[hmap_file_trapdoor];
        block_index = file_index/ENCRYPT_BLOCK_SIZE;
        if(block_index > NUM_BLOCKS)
        {
            printf("Error!!\n");
            exit(1);
        }
    }
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    delete dsse_trapdoor;
    return 0;
}


/**
 * Function Name: pickRandom_element
 *
 * Description:
 * Uniformly select an element at random from a set
 *
 * @param random_element: (output) element being picked
 * @param setIdx: (input) set of indices
 * @param prng: pseudo-random number state according to libtomcrypt
 * @return	0 if successful
 */
 
int DSSE::pickRandom_element(TYPE_INDEX &random_element, vector<TYPE_INDEX> &setIdx,prng_state* prng)
{
    TYPE_INDEX random_idx;
    unsigned char pseudo_random_number [BLOCK_CIPHER_SIZE];
    int seed_len = BLOCK_CIPHER_SIZE ; 
	int error = 0;
   
    TYPE_INDEX tmp;
    
    memset(pseudo_random_number,0,BLOCK_CIPHER_SIZE);               
	
    // Generate random number 
    fortuna_read(pseudo_random_number, BLOCK_CIPHER_SIZE, prng);
    
    memcpy(&tmp,&pseudo_random_number[7],sizeof(tmp)); // TAKE A HALF OF PSEUDO RANDOM NUMBER VARIABLE
    random_idx = tmp % setIdx.size();
    
    random_element = setIdx[random_idx];
    setIdx.erase(setIdx.begin()+random_idx);


    memset(pseudo_random_number,0,BLOCK_CIPHER_SIZE);
    return 0;
}

/**
 * Function Name: scanDatabase
 *
 * Description:
 * Scan the file collection to determine the total numbers of files and unique keywords being extracted, and to estimate the size of 2 hash tables at client
 *
 * @param rFileName: (output) list of files in the file collection
 * @param rKeywordDictionary: (output) list of unique keywords being extracted
 * @param rT_W: (output) keyword hash table
 * @param rT_F: (output) file hash table
 * @param path: (input) location of the file collection
 * @param pKey: (input) symmetric keys
 * @return	0 if successful
 */
int DSSE::scanDatabase(
		vector<string> &rFileNames,
		TYPE_KEYWORD_DICTIONARY &rKeywordsDictionary,
        TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        string path,
        MasterKey* pKey)
{

	int keyword_len = 0;
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE], file_trapdoor[TRAPDOOR_SIZE];
	string word;
	DIR *pDir;
	struct dirent *pEntry;
	struct stat file_stat;
	string file_name, file_name_with_path;
	TYPE_KEYWORD_DICTIONARY words_per_file;
	set<string>::iterator iter;
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
	try
    {
		if((pDir=opendir(path.c_str())) != NULL)
        {
			while((pEntry = readdir(pDir))!=NULL)
            {
				file_name = pEntry->d_name;
				if(!file_name.compare(".") || !file_name.compare("..")) 
                {
					continue;
				}
				else
                {
					file_name_with_path = path + pEntry->d_name;                                      // "/" +

					// If the file is a directory (or is in some way invalid) we'll skip it
					if (stat(file_name_with_path.c_str(), &file_stat)) continue;

					if (S_ISDIR(file_stat.st_mode))
                    {
						file_name_with_path.append("/");
                        scanDatabase(rFileNames, rKeywordsDictionary, rT_W, rT_F, file_name_with_path,pKey);
						continue;
					}
                    if(file_name_with_path.size() > 0)
                    {
						dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
								(unsigned char *)file_name_with_path.c_str(), 
								file_name_with_path.size(), pKey);
                    }
					else
						printf("File name is empty\n");

					hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
                    
                    rT_F[hmap_file_trapdoor] = FILE_NOT_EXIST; // assign empty values to this
                    
					rFileNames.push_back(file_name_with_path.c_str());
            
                    KeywordExtraction* wordext = new KeywordExtraction(); 
					wordext->extractKeywords(words_per_file, file_name, path);

					for(iter=words_per_file.begin();iter != words_per_file.end();iter++) 
                    {
                        word = *iter;
						keyword_len = word.size();
                        if(keyword_len>0)
                        {
                            dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
									(unsigned char *)word.c_str(), keyword_len, pKey);
                            rKeywordsDictionary.insert(word);
                        }
						else
                        {
                            continue;
                        }
						hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor,TRAPDOOR_SIZE);
    
                        rT_W[hmap_keyword_trapdoor] = KEYWORD_NOT_EXIST;
                        
                        // Clearing contents
						word.clear();
					}
					// Clearing contents
					words_per_file.clear();
					file_name_with_path.clear();
				}
				// Clearing contents
				file_name.clear();
			}

			closedir(pDir);
		}
		else
        {
			cout << "Could not locate the directory..." << endl;
		}
	}
    catch(exception &e)
    {
		cout << "Error occurred in generate_file_trapdoors function " << e.what() << endl;
	}
	return 0;
}

/**
 * Function Name: createKeyword_file_pair
 *
 * Description:
 * create keyword-file pair from the file collection
 *
 * @param kw_file_pair: (output) list of keyword-file pair being extracted
 * @param rT_W: (output) keyword hash table 
 * @param rT_F: (output) file hash table
 * @param lstFree_keyword_idx: (input) list of empty indices used for keyword (e.g., empty row index)
 * @param lstFree_file_idx: (input) list of empty indices used for file (e.g., empty column index)
 * @param path: (input) location of the file collection
 * @param pKey: (input) key generated by genMasterKey which is used for hash table
 * @return	0 if successful
 */
int DSSE::createKeyword_file_pair(
        vector<vector<TYPE_INDEX>> &kw_file_pair,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_W,
		TYPE_GOOGLE_DENSE_HASH_MAP &rT_F,
        vector<TYPE_INDEX> &lstFree_keyword_idx,
        vector<TYPE_INDEX> &lstFree_file_idx,
		string path,
		MasterKey *pKey)
{
	int keyword_len = 0;
	TYPE_INDEX row = 0,file_index = 0;
	unsigned char keyword_trapdoor[TRAPDOOR_SIZE];
	unsigned char file_trapdoor[TRAPDOOR_SIZE];
	string word;
	DIR *pDir;
	struct dirent *pEntry;
	struct stat file_stat;
	string file_name, file_name_with_path;
	TYPE_KEYWORD_DICTIONARY words_per_file;
	set<string>::iterator iter;

    KeywordExtraction* kw_ex = new KeywordExtraction();
    DSSE_Trapdoor* dsse_trapdoor = new DSSE_Trapdoor();
    
    TYPE_INDEX selectedIdx;
    try
    {
		if((pDir=opendir(path.c_str())) != NULL)
        {
			while((pEntry = readdir(pDir))!=NULL)
            {
				file_name = pEntry->d_name;
                // look into pEntry 
				if(!file_name.compare(".") || !file_name.compare("..")) 
                {
					continue;
				}
				else
                {
					file_name_with_path = path + pEntry->d_name; 
					// If the file is a directory (or is in some way invalid) we'll skip it
					if (stat(file_name_with_path.c_str(), &file_stat)) 
                        continue;
					if (S_ISDIR(file_stat.st_mode))
                    {
						file_name_with_path.append("/");
						createKeyword_file_pair(kw_file_pair, rT_W, rT_F, lstFree_keyword_idx, lstFree_file_idx, file_name_with_path, pKey);
						continue;
					}
					if(file_name_with_path.size() > 0)
                    {
						dsse_trapdoor->generateTrapdoor_single_input(file_trapdoor, TRAPDOOR_SIZE,	
								(unsigned char *)file_name_with_path.c_str(), 
								file_name_with_path.size(), pKey);
                    }
					else
						printf("File name is empty\n");

					hashmap_key_class hmap_file_trapdoor(file_trapdoor,TRAPDOOR_SIZE);
                    
					// Get the file index from the hashmap
                    if(rT_F[hmap_file_trapdoor] == FILE_NOT_EXIST)
                    {
                        this->pickRandom_element(selectedIdx,lstFree_file_idx,&prng);
                        rT_F[hmap_file_trapdoor] = selectedIdx;
                    }	
                   
                    kw_ex->extractKeywords(words_per_file, file_name, path);
                    
                    for(iter=words_per_file.begin();iter != words_per_file.end();iter++) 
                    {
						word = *iter;
						keyword_len = word.size();
                        if(keyword_len>0)
                        {
							dsse_trapdoor->generateTrapdoor_single_input(keyword_trapdoor, TRAPDOOR_SIZE, 
									(unsigned char *)word.c_str(), keyword_len, pKey);
                        }
						else
                        {
                            continue;
                        }
						hashmap_key_class hmap_keyword_trapdoor(keyword_trapdoor,TRAPDOOR_SIZE);
    
                        if(rT_W[hmap_keyword_trapdoor] == KEYWORD_NOT_EXIST)
                        {
                            this->pickRandom_element(selectedIdx,lstFree_keyword_idx,&prng);
                            rT_W[hmap_keyword_trapdoor] = selectedIdx;
                            
                        }

                        row = rT_W[hmap_keyword_trapdoor];

                        file_index = rT_F[hmap_file_trapdoor];
                        
                        //build the keyword file pair
                        kw_file_pair[file_index].push_back(row);
                    
						word.clear();
					}
					words_per_file.clear();
					file_name_with_path.clear();
				}
				file_name.clear();
			}

			closedir(pDir);
		}
		else
        {
			printf("Could not locate the directory...\n");
		}
	}
    catch(exception &e)
    {
        printf("Error!!\n");
        exit(1);
	}

    memset(keyword_trapdoor,0,TRAPDOOR_SIZE);
	memset(file_trapdoor,0,TRAPDOOR_SIZE);
	word.clear();
	delete pEntry;
	file_name.clear(); 
    file_name_with_path.clear();
	words_per_file.clear();
	delete kw_ex;
    delete dsse_trapdoor;
	
    return 0;
}

/**
 * Function Name: createEncrypted_matrix_from_kw_file_pair
 *
 * Description:
 * create the DSSE encrypted data structure from the keyword-file pairs extracted and write it to file named FILENAME_MATRIX (config.h)
 *
 * @param kw_file_pair: (input) list of keyword-file pair being extracted
 * @param row_counter_arr: (input) row counters
 * @param block_counter_arr: (input) column (block) counters
 * @param pKey: (input) key generated by genMasterKey which is used to encrypt DSSE data structure
 * @return	0 if successful
 */
int DSSE::createEncrypted_matrix_from_kw_file_pair(vector<vector<TYPE_INDEX>> &kw_file_pair, 
                                                    TYPE_COUNTER *row_counter_arr,
                                                    TYPE_COUNTER* block_counter_arr,
                                                    MasterKey *pKey)
{
    int n; 
    TYPE_INDEX curIdx;
    TYPE_INDEX size_row;
    TYPE_INDEX col, row, row_idx;
    TYPE_INDEX vector_idx = 0;
    TYPE_INDEX ii,jj;
    int bit_number;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;

    unsigned char U[BLOCK_CIPHER_SIZE];
    unsigned char V[BLOCK_CIPHER_SIZE];
    unsigned char uchar_counter[BLOCK_CIPHER_SIZE];
    TYPE_INDEX block_idx;
    unsigned char row_key [BLOCK_CIPHER_SIZE];
    unsigned char row_key_input [BLOCK_CIPHER_SIZE];
    DSSE_KeyGen* dsse_keygen = new DSSE_KeyGen();
    
    MatrixType** I = new MatrixType*[MATRIX_ROW_SIZE];
    for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
    {
        I[m] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I[m],0,MATRIX_PIECE_COL_SIZE);
    }
    
    block_idx = 0;
   
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
        {
            memset(I[m],0,MATRIX_PIECE_COL_SIZE);
        }
        for(curIdx  = MATRIX_PIECE_COL_SIZE*i,col=0; curIdx < MATRIX_PIECE_COL_SIZE * (i+1); col++,curIdx++)
        {
            for(bit_number = 0 ; bit_number < BYTE_SIZE; bit_number++)
            {
                vector_idx = curIdx * BYTE_SIZE + bit_number;
                for(row = 0, size_row = kw_file_pair[vector_idx].size(); row < size_row; row++)
                {
                    row_idx = kw_file_pair[vector_idx][row];
                    BIT_SET(&I[row_idx][col].byte_data,bit_number);
                }
            }
        }
 
		for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
		{
			memcpy(row_key_input,&row,sizeof(row));
			memcpy(&row_key_input[BLOCK_CIPHER_SIZE/2],&row_counter_arr[row],sizeof(row_counter_arr[row]));
			
			dsse_keygen->genRow_key(row_key, BLOCK_CIPHER_SIZE, row_key_input, BLOCK_CIPHER_SIZE, pKey);
			
			block_idx = (MATRIX_PIECE_COL_SIZE*BYTE_SIZE/ENCRYPT_BLOCK_SIZE)*i; 
			for(jj = 0; jj < MATRIX_PIECE_COL_SIZE*BYTE_SIZE; jj+=ENCRYPT_BLOCK_SIZE,block_idx++)
			{
				col = jj / BYTE_SIZE;
				for(ii=0, bit_number = jj % BYTE_SIZE ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
				{
					if(BIT_CHECK(&I[row][col].byte_data,bit_number))
						BIT_SET(&U[0],ii);
					else
						BIT_CLEAR(&U[0],ii);
				}
				memset(uchar_counter,0,BLOCK_CIPHER_SIZE);
				memcpy(&uchar_counter[BLOCK_CIPHER_SIZE/2],&block_counter_arr[block_idx],sizeof(TYPE_COUNTER));
				memcpy(&uchar_counter,&block_idx,sizeof(TYPE_INDEX));
				// Encrypting the  matrix I using AES CTR 128 function
				aes128_ctr_encdec(U, V, row_key, uchar_counter, ONE_VALUE);
				// Write the encryped row back to matrix I
				for(ii=0,bit_number = jj % BYTE_SIZE ; ii< ENCRYPT_BLOCK_SIZE;ii++,bit_number++)
				{
				
					if(BIT_CHECK(&V[0],ii))
						BIT_SET(&I[row][col].byte_data,bit_number);
					else
						BIT_CLEAR(&I[row][col].byte_data,bit_number);
				}
			}
		}
		//write the matrix to file by spliting it to smaller chunks
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE ; m +=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
    }
   
    for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m++)
    {
        delete[] I[m];
    }
    delete[] I;
	
	//Create encrypted keyword counter array-OZG
	unsigned char* encrypted_keyword_counter_array;
	
	encrypted_keyword_counter_array = new unsigned char[MATRIX_ROW_SIZE*BLOCK_CIPHER_SIZE];
	
	unsigned char counter_keyword [BLOCK_CIPHER_SIZE] = {0};
	unsigned char plaintext [BLOCK_CIPHER_SIZE] = {0};
	
	
    for(row = 0 ; row < MATRIX_ROW_SIZE ; row++){
		memcpy(counter_keyword,&row,sizeof(row));
		memcpy(plaintext, &row_counter_arr[row], sizeof(TYPE_COUNTER));
		aes128_ctr_encdec(plaintext, encrypted_keyword_counter_array+row*BLOCK_CIPHER_SIZE, pKey->key4, counter_keyword, ONE_VALUE);
		memset(counter_keyword,0,BLOCK_CIPHER_SIZE);
		memset(plaintext,0,BLOCK_CIPHER_SIZE);
	}
	
	misc.write_encArray_to_file(FILENAME_ENCRYPTED_KEYWORD_COUNTER_ARRAY, gcsDataStructureFilepath , encrypted_keyword_counter_array, MATRIX_ROW_SIZE*BLOCK_CIPHER_SIZE);
	
    delete[] encrypted_keyword_counter_array;
	
    return 0;
}


int DSSE::decryptKeywordCounter(TYPE_COUNTER *row_counter_arr, unsigned char* encryptedRow, MasterKey *pKey){
	TYPE_INDEX row;
	unsigned char counter_keyword [BLOCK_CIPHER_SIZE] = {0};
	unsigned char plaintext [BLOCK_CIPHER_SIZE] = {0};
	
	for(row = 0 ; row < MATRIX_ROW_SIZE ; row++){
		memcpy(counter_keyword,&row,sizeof(row));
		aes128_ctr_encdec(encryptedRow + row*BLOCK_CIPHER_SIZE, plaintext, pKey->key4, counter_keyword, ONE_VALUE);
		memcpy(&row_counter_arr[row], plaintext, sizeof(TYPE_COUNTER));
		memset(counter_keyword,0,BLOCK_CIPHER_SIZE);
		memset(plaintext,0,BLOCK_CIPHER_SIZE);
	}
	
	return 0;
}

int DSSE::reEncryptKeywordCounter(unsigned char* encryptedRow, TYPE_COUNTER *row_counter_arr, MasterKey *pKey){
	TYPE_INDEX row;
	unsigned char counter_keyword [BLOCK_CIPHER_SIZE] = {0};
	unsigned char plaintext [BLOCK_CIPHER_SIZE] = {0};
	memset(encryptedRow, 0, BLOCK_CIPHER_SIZE*MATRIX_ROW_SIZE);
	
    for(row = 0 ; row < MATRIX_ROW_SIZE ; row++){
		memcpy(counter_keyword,&row,sizeof(row));
		memcpy(plaintext, &row_counter_arr[row], sizeof(TYPE_COUNTER));
		aes128_ctr_encdec(plaintext, encryptedRow+row*BLOCK_CIPHER_SIZE, pKey->key4, counter_keyword, ONE_VALUE);
		memset(counter_keyword,0,BLOCK_CIPHER_SIZE);
		memset(plaintext,0,BLOCK_CIPHER_SIZE);
	}
	
	return 0;
}


/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from the file named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE];
    memset(I_piece,0,MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE);
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename,gcsMatrixPiecePath,&I_piece[m*MATRIX_PIECE_COL_SIZE],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col+ (i*MATRIX_PIECE_COL_SIZE);
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                I[row][I_col_idx].byte_data = I_piece[row*MATRIX_PIECE_COL_SIZE+col].byte_data;
            }
        }
    }
    delete[] I_piece;
    return 0;
}


/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to the files named FILENAME_MATRIX located at gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = MATRIX_COL_SIZE/MATRIX_PIECE_COL_SIZE;
    MatrixType *I_piece = new MatrixType[MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE];
    memset(I_piece,0,MATRIX_PIECE_COL_SIZE*MATRIX_ROW_SIZE);
    for(int i = 0 ; i < n ; i++)
    {
        for(col = 0; col < MATRIX_PIECE_COL_SIZE; col++)
        {
            I_col_idx = col+ (i*MATRIX_PIECE_COL_SIZE);
            for(row = 0 ; row < MATRIX_ROW_SIZE ; row++)
            {
                I_piece[row*MATRIX_PIECE_COL_SIZE+col].byte_data = I[row][I_col_idx].byte_data;
            }
        }
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(i*MATRIX_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I_piece[m*MATRIX_PIECE_COL_SIZE],MATRIX_PIECE_ROW_SIZE,MATRIX_PIECE_COL_SIZE);
        }
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: createBlock_state_matrix_files
 *
 * Description:
 * Initialize the block state matrix and save it to files 
 * 
 * @return	0 if successful
 */
int DSSE::createBlock_state_matrix_files()
{
    int n; 
    Miscellaneous misc;
    n = (NUM_BLOCKS/BLOCK_STATE_PIECE_COL_SIZE);
    n = n /BYTE_SIZE;

    MatrixType** I_chunk = new MatrixType*[BLOCK_STATE_PIECE_ROW_SIZE];
    TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
    for(TYPE_INDEX k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        I_chunk[k] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        cout<<endl<<i<<"...."<<endl;
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE ; m +=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            for(int k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
            {
                memset(I_chunk[k],0,kk);
            }
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,I_chunk,BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
    }
    for(TYPE_INDEX k = 0 ; k < BLOCK_STATE_PIECE_ROW_SIZE; k++)
    {
        delete[] I_chunk[k]; 
    }
    delete[] I_chunk;
    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a small-piece of block state matrix from files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (output) Block state matrix
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS/BYTE_SIZE/BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType*[BLOCK_STATE_ROW_SIZE];
    
    TYPE_INDEX kk=BLOCK_STATE_PIECE_COL_SIZE ;

    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            misc.read_matrix_from_file(filename,gcsMatrixPiecePath,&I_piece[m],BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col+ (i*kk);
            for(row = 0 ; row < BLOCK_STATE_ROW_SIZE ; row++)
            {
                I[row][I_col_idx] = I_piece[row][col];
            }
        }
    }
    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}


/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save block state matrix to files located gcsMatrixPiecePath (config.h)
 *
 * @param I: (input) Block state matrix
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType** I)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    n = NUM_BLOCKS/BYTE_SIZE/BLOCK_STATE_PIECE_COL_SIZE;
    MatrixType **I_piece = new MatrixType*[BLOCK_STATE_ROW_SIZE];
    
    TYPE_INDEX kk=BLOCK_STATE_PIECE_COL_SIZE ;

    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        I_piece[m] = new MatrixType[kk];
    }
    for(int i = 0 ; i < n ; i++)
    {
        for(col = 0; col < kk; col++)
        {
            I_col_idx = col+ (i*kk);
            for(row = 0 ; row < BLOCK_STATE_ROW_SIZE ; row++)
            {
                I_piece[row][col] = I[row][I_col_idx] ;
            }
        }
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(i*BLOCK_STATE_PIECE_COL_SIZE);
            misc.write_matrix_to_file(filename,gcsMatrixPiecePath,&I_piece[m],BLOCK_STATE_PIECE_ROW_SIZE,kk);
        }
        
    }
    for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m++)
    {
        delete[] I_piece[m];
    }
    delete[] I_piece;
    return 0;
}

/**
 * Function Name: getBlock
 *
 * Description:
 * get the block data from the encrypted data structure, given a block index and the dimension
 *
 * @param block_index: (input) block index
 * @param dim: dimension (ROW or COL)
 * @param I_prime: (output) block data
 * @param I: (input) DSSE encrypted data structure
 * @return	0 if successful
 */
int DSSE::getBlock( TYPE_INDEX index,    
                        int dim,
                        MatrixType** I,
                        MatrixType* I_prime)
{    
    TYPE_INDEX row, col;
    TYPE_INDEX I_prime_col;
    try
    {
        if(dim==COL)
        {
            TYPE_INDEX I_prime_idx = 0;
            TYPE_INDEX begin;
            TYPE_INDEX end;

			TYPE_INDEX I_bit_idx, I_prime_bit_idx;
			col = (index*ENCRYPT_BLOCK_SIZE) / BYTE_SIZE;
			begin = (index*ENCRYPT_BLOCK_SIZE) % BYTE_SIZE;
			end = begin + ENCRYPT_BLOCK_SIZE;
			for(row = 0 ; row < MATRIX_ROW_SIZE; row++)
			{  
				for(I_bit_idx = begin; I_bit_idx < end; I_bit_idx++,I_prime_idx++)
				{
					I_prime_col = I_prime_idx / BYTE_SIZE;
					I_prime_bit_idx = I_prime_idx % BYTE_SIZE;
					
					if(BIT_CHECK(&I[row][col].byte_data,I_bit_idx))
						BIT_SET(&I_prime[I_prime_col].byte_data,I_prime_bit_idx);
					else
						BIT_CLEAR(&I_prime[I_prime_col].byte_data,I_prime_bit_idx);
				}
			}
            
            
        }
        else
        {
            memcpy(I_prime,I[index],MATRIX_COL_SIZE);
        }
    }    
    catch(exception &e)
    {
		printf("Error!!\n");
        exit(1);
    }

    return 0;
}

/**
 * Function Name: loadEncrypted_matrix_from_files
 *
 * Description:
 * Load the DSSE encrypted data structure from a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only loads a single block of encrypted data structure appropriate with the index
 * @param I: (output) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::loadEncrypted_matrix_from_files(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx*ENCRYPT_BLOCK_SIZE)  / (MATRIX_PIECE_COL_SIZE* BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE)/(BYTE_SIZE));
        
        TYPE_INDEX n1 = (idx*ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE*BYTE_SIZE) /BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE-n1-c;
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename =  misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,c,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE) * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0],0,MATRIX_PIECE_COL_SIZE);
    
        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n  +=MATRIX_PIECE_COL_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,I_tmp,1,MATRIX_PIECE_COL_SIZE,m1,0,dim);
            memcpy(&I[0][n],I_tmp[0],MATRIX_PIECE_COL_SIZE);
            
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }

    return 0;
}


/**
 * Function Name: saveEncrypted_matrix_to_files
 *
 * Description:
 * Save the DSSE encrypted data structure to a corresponding file located at gcsMatrixPiecePath (config.h)
 * This function only saves a single block of encrypted data structure appropriate with the index
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::saveEncrypted_matrix_to_files(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx*ENCRYPT_BLOCK_SIZE)  / (MATRIX_PIECE_COL_SIZE* BYTE_SIZE) * MATRIX_PIECE_COL_SIZE;
        TYPE_INDEX c = ceil((double)(ENCRYPT_BLOCK_SIZE)/(BYTE_SIZE));
        
        TYPE_INDEX n1 = (idx*ENCRYPT_BLOCK_SIZE) % (MATRIX_PIECE_COL_SIZE*BYTE_SIZE) /BYTE_SIZE;
        TYPE_INDEX n2 = MATRIX_PIECE_COL_SIZE-n1-c;
        
        for(TYPE_INDEX m = 0 ; m < MATRIX_ROW_SIZE; m+=MATRIX_PIECE_ROW_SIZE)
        {
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,&I[m],MATRIX_PIECE_ROW_SIZE,c,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / MATRIX_PIECE_ROW_SIZE)  * MATRIX_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % MATRIX_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[MATRIX_PIECE_COL_SIZE];
        memset(I_tmp[0],0,MATRIX_PIECE_COL_SIZE);
        
        for(TYPE_INDEX n = 0; n < MATRIX_COL_SIZE; n +=MATRIX_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0],&I[0][n],MATRIX_PIECE_COL_SIZE);
            string filename = misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,I_tmp,1,MATRIX_PIECE_COL_SIZE,m1,0,dim);
            
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

/**
 * Function Name: saveBlock_state_matrix_to_file
 *
 * Description:
 * Save a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only save a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::saveBlock_state_matrix_to_file(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    if (dim == COL)
    {
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;
        
        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE*BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE-n1-1;
        
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" +misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,&I[m],BLOCK_STATE_PIECE_ROW_SIZE,1,n1,n2,dim);
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1=idx % BLOCK_STATE_PIECE_ROW_SIZE;
        
        MatrixType** I_tmp = new MatrixType*[1];
        I_tmp[0] = new MatrixType[BLOCK_STATE_PIECE_COL_SIZE];
        memset(I_tmp[0],0,BLOCK_STATE_PIECE_COL_SIZE);
        
        for(TYPE_INDEX n = 0; n < NUM_BLOCKS/BYTE_SIZE; n +=BLOCK_STATE_PIECE_COL_SIZE)
        {
            memcpy(I_tmp[0],&I[0][n],BLOCK_STATE_PIECE_COL_SIZE);
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.write_single_block_to_file(filename,gcsMatrixPiecePath,I_tmp,1,BLOCK_STATE_PIECE_COL_SIZE,m1,0,dim);
        }
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

/**
 * Function Name: loadBlock_state_matrix_from_file
 *
 * Description:
 * Load a single block state matrix to files located gcsMatrixPiecePath (config.h)
 * This function only load a single block state matrix appropriate with the index and dimension
 * @param I: (input) DSSE encrypted data structure
 * @param dim: (input) dimension (row or column)
 * @param idx: (input) index
 * 
 * @return	0 if successful
 */
int DSSE::loadBlock_state_matrix_from_file(MatrixType** I, int dim, TYPE_INDEX idx)
{
    int n; 
    TYPE_INDEX col, row, I_col_idx;
    Miscellaneous misc;
    
    if (dim == COL)
    {
        //calculate the 2nd index of filename need to be loaded based on the input idx
        TYPE_INDEX n = (idx / BYTE_SIZE / BLOCK_STATE_PIECE_COL_SIZE) * BLOCK_STATE_PIECE_COL_SIZE;
        TYPE_INDEX n1 = (idx % (BLOCK_STATE_PIECE_COL_SIZE*BYTE_SIZE)) / BYTE_SIZE;
        TYPE_INDEX n2 = BLOCK_STATE_PIECE_COL_SIZE-n1-1;
        
        for(TYPE_INDEX m = 0 ; m < BLOCK_STATE_ROW_SIZE; m+=BLOCK_STATE_PIECE_ROW_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,&I[m],BLOCK_STATE_PIECE_ROW_SIZE,1,n1,n2,dim);
            
        }
    }
    else
    {
        TYPE_INDEX m = (idx / BLOCK_STATE_PIECE_ROW_SIZE) * BLOCK_STATE_PIECE_ROW_SIZE;
        TYPE_INDEX m1 = idx % BLOCK_STATE_PIECE_ROW_SIZE;
        MatrixType** I_tmp = new MatrixType*[1];
        TYPE_INDEX kk = BLOCK_STATE_PIECE_COL_SIZE;
        I_tmp[0] = new MatrixType[kk];
        memset(I_tmp[0],0,kk);
        
        for(TYPE_INDEX n = 0; n < NUM_BLOCKS/BYTE_SIZE; n  +=BLOCK_STATE_PIECE_COL_SIZE)
        {
            string filename = "b_" + misc.to_string(m) + "_" + misc.to_string(n);
            misc.read_single_block_from_file(filename,gcsMatrixPiecePath,I_tmp,1,kk,m1,0,dim);
            memcpy(&I[0][n],I_tmp[0],kk);
        }
    
        delete[] I_tmp[0];
        delete[] I_tmp;
    }
    
    return 0;
}

